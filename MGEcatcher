#!/bin/bash

set -e

#usage
usage() {
USAGE="
                              ███╗   ███╗ ██████╗ ███████╗             
                              ████╗ ████║██╔════╝ ██╔════╝             
                              ██╔████╔██║██║  ███╗█████╗               
                              ██║╚██╔╝██║██║   ██║██╔══╝               
                              ██║ ╚═╝ ██║╚██████╔╝███████╗             
                              ╚═╝     ╚═╝ ╚═════╝ ╚══════╝             
               ██████╗ █████╗ ████████╗ ██████╗██╗  ██╗███████╗██████╗ 
              ██╔════╝██╔══██╗╚══██╔══╝██╔════╝██║  ██║██╔════╝██╔══██╗
              ██║     ███████║   ██║   ██║     ███████║█████╗  ██████╔╝
              ██║     ██╔══██║   ██║   ██║     ██╔══██║██╔══╝  ██╔══██╗
              ╚██████╗██║  ██║   ██║   ╚██████╗██║  ██║███████╗██║  ██║
               ╚═════╝╚═╝  ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝

══════════════════════════════════════════════════════════════════════════════════
                 Automated pipeline to identify mobile genetic elements 
                          in long read DNA sequencing data
----------------------------------------------------------------------------------
                          by: Vinícius Franceschini-Santos, 2022
══════════════════════════════════════════════════════════════════════════════════

\e[4mUsage\e[0m:

MGEcatcher --reads <reads.fq> --mge_seed <mge.fa> [--threads <N>] \\
           --output <path/to/output/> --prefix <BC01>

\e[4mRequired arguments\e[0m:
     --reads        Fastq file for basecalled reads to be used as subject

     --mge_seed     Fasta file containing MGE sequences to be used as query

     --output       Output dir name; will be created if does not exist

     --prefix       Barcode identifier (ex.: BC01)

\e[4mOptional arguments\e[0m:
     --threads      Number of threads (default: 10)

"
echo -e "$USAGE"
exit 2
}

# error function
error_exit() {
        msg=$1
        exit_code=${2:-1}
        echo -e "\033[1;31m${msg}\033[0m"
        usage
}

# thanks, stackoverflow!
join_path() {
    echo "${1:+$1/}$2" | sed 's#//#/#g'
}

check_deps() {
    for app in blastn bedtools; do
        command -v $CONDA_PREFIX/bin/$app >/dev/null 2>&1 || error_exit \
                "ERROR: Cannot find ${app}. Make sure it is installed and in your PATH variable"
    done
}


VERSION=0.2
check_deps


HOME_DIR=${0%/*}
# Log message function (normal text)
log() {
	printf '[ %(%y-%m-%d %H:%M:%S)T] '
	printf "%*s\n" 61 "$1"
}
# Warning message function (yellow text)
warn() {
	echo -e "\033[1;33m"$1"\033[0m"
	}
# "Done" message function
DONEmsg() {
	printf '[ %(%y-%m-%d %H:%M:%S)T] '
	printf "%*s\n" 61 "Done!"
}
# parse args

THREADS=10
# option strings
SHORT=h
LONG=help,reads:,prefix:,mge_seed:,output:,threads:

# read the options
OPTS=$(getopt --options $SHORT --long $LONG --name "$0" -- "$@")
if [ $? != 0 ] ; then echo "Failed to parse options...exiting." ; exit 1 ; fi
eval set -- "$OPTS"
while true ; do
  case "$1" in
    -h | --help )
      usage
      ;;
    --reads )
      READS="$2"
      shift 2
	 ;;
    --threads )
      THREADS="$2"
      shift 2
	 ;;
    --mge_seed )
       MGE="$2"
      shift 2
	 ;;
    --output )
       OUTPUT="$2"
      shift 2
	 ;;
    --prefix )
      BC="$2"
     shift 2
	 ;;
    -- )
     shift
     break
     ;;
    *)
     error_exit "ERROR: Please, supply required arguments correctly."
     ;;
 esac
done


declare -A array # associative arrays need to be declared!
array=( [--reads]="${READS}" [--mge_seed]="${MGE}" \
		[--output]="${OUTPUT}" [--prefix]="${BC}" \
		[--threads]="${THREADS}")

for idx in "${!array[@]}"; do
	if [[ ! ${array[$idx]} ]]; then
	echo "ERROR: $idx argument must be supplied. ${array[$idx]} exiting..."
	usage
	fi
done


echo "
                             ███╗   ███╗ ██████╗ ███████╗             
                             ████╗ ████║██╔════╝ ██╔════╝             
                             ██╔████╔██║██║  ███╗█████╗               
                             ██║╚██╔╝██║██║   ██║██╔══╝               
                             ██║ ╚═╝ ██║╚██████╔╝███████╗             
                             ╚═╝     ╚═╝ ╚═════╝ ╚══════╝             
              ██████╗ █████╗ ████████╗ ██████╗██╗  ██╗███████╗██████╗ 
             ██╔════╝██╔══██╗╚══██╔══╝██╔════╝██║  ██║██╔════╝██╔══██╗
             ██║     ███████║   ██║   ██║     ███████║█████╗  ██████╔╝
             ██║     ██╔══██║   ██║   ██║     ██╔══██║██╔══╝  ██╔══██╗
             ╚██████╗██║  ██║   ██║   ╚██████╗██║  ██║███████╗██║  ██║
              ╚═════╝╚═╝  ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝

══════════════════════════════════════════════════════════════════════════════════
                Automated pipeline to identify mobile genetic elements 
                          in long read DNA sequencing data
----------------------------------------------------------------------------------
                       by: Vinícius Franceschini-Santos, 2021
══════════════════════════════════════════════════════════════════════════════════"
printf "%s%*s\n" "Reads:" 76 "${READS}"
printf "%s%*s\n" "MGE seed:" 73 "${MGE}"
printf "%s%*s\n" "Output dir:" 71 "${OUTPUT}" 
printf "%s%*s\n" "Threads:" 74 "${THREADS}"
printf "%s%*s\n" "Prefix:" 75 "${BC}"
echo "══════════════════════════════════════════════════════════════════════════════════"
# make temp files
mkdir -p ${OUTPUT}
mkdir -p ${OUTPUT}/tmp/

READ_BNAME=`basename ${READS}`

FASTA=${OUTPUT}/tmp/${READ_BNAME%.*}.fasta

if [ ! -f ${FASTA} ]; then
	log "Converting input reads to fasta"
	sed -n '1~4s/^@/>/p;2~4p' ${READS} > ${FASTA}

else
	warn "File ${FASTA} already exists... skipping"
fi

if [ ! -f ${FASTA}.nsq ]; then
	log "Creating database for BLAST"
	$CONDA_PREFIX/bin/makeblastdb -in ${FASTA} \
		-dbtype nucl > /dev/null 2> /dev/null

else
	warn "Blast database already exists... skipping"
fi

MAPPINGOUT=${OUTPUT}/tmp/${READ_BNAME%.*}.MGE-mapping

if [ ! -f "${MAPPINGOUT}" ]; then
        log "Mapping MGEs with $(basename ${MGE})"
        $CONDA_PREFIX/bin/blastn -db ${FASTA} -query ${MGE} \
		-strand plus \
		-evalue 1e-03 \
		-outfmt "7 qacc sacc sstart send qlen slen evalue" \
		-task blastn -num_threads ${THREADS} \
		-out $MAPPINGOUT > ${OUTPUT}/tmp/MGE-mapping.err 2>&1
	
else
	warn "MGE-mapping already done... skipping"
fi

#### RSCRIPT TO REDUCE OVERLAPS
echo "
#!/usr/bin/env Rscript
options(warn=-1)
args = commandArgs(trailingOnly=T)

suppressPackageStartupMessages({
    	require(GenomicRanges)
    	require(IRanges)
    	require(ggbio)
    	require(dplyr)
})

# writting functions to be called in apply furtherly

GetMGEName = function(x){
        paste(x[2],
        x[5],
        strsplit(x[1],split = \"::\")[[1]][1],
        x[8],
        sep=\"_\")
}

GetLen4reduced = function(x){
    	sqname = x[1]
    	x[6] = seqlen[sqname]
}

GetReadName = function(x){
    	read = x[1]
    	id = x[7]
    	paste(read,id,sep=\"_\")
}

filtered_data = args[1]
reduced_data = args[2]

df = read.table(filtered_data)
df\$row = rownames(df)

df\$MGE = apply(df,
        FUN = GetMGEName,
        MARGIN = 1)

df = df[,c(2,3,4,6,9)]
colnames(df) = c(\"seqnames\", \"start\", \"end\", \"seqlength\", \"MGE\")
df\$strand = \"+\"
toPlot = head(df,10)

gr = makeGRangesFromDataFrame(df,
                              seqnames.field=\"seqnames\",
                              start.field=\"start\",
                              end.field=\"end\",
                              strand.field=\"strand\")

tmp = makeGRangesFromDataFrame(toPlot,
                              seqnames.field=\"seqnames\",
                              start.field=\"start\",
                              end.field=\"end\",
                              strand.field=\"strand\")

dfnames = toPlot[,c(1,4)]
dfnames = distinct(dfnames)
seqlen = dfnames\$seqlength
names(seqlen) = dfnames\$seqnames
tmp = GRanges(tmp, seqlengths = seqlen)

dfnames = df[,c(1,4)]
dfnames = distinct(dfnames)
seqlen = dfnames\$seqlength
names(seqlen) = dfnames\$seqnames
toReduce = GRanges(gr, seqlengths = seqlen)

Reduced = reduce(toReduce)
tmp = reduce(tmp)

pdf(paste0(reduced_data, \".viz.pdf\"))

suppressMessages({
autoplot(tmp, aes(fill=\"strand\"), layout = \"karyogram\") +
        scale_fill_manual(values = \"\#d95f02\") +
        ggtitle(\"MGE mapping\", subtitle = \"First 10 mappings\") +
        theme(legend.position = \"none\", 
            axis.text.x = element_text(angle=90,vjust=0.5,hjust=0.5))
})

final_df = as.data.frame(Reduced) 

final_df\$seqlen = apply(final_df, 
        FUN = GetLen4reduced,
        MARGIN = 1)

final_df = final_df[,c(1,2,3,6)]

write.table(final_df, reduced_data,
        quote=F, row.names = F, col.names = F)

dev.off()
" > ${OUTPUT}/ReduceOverlappingMGEs.R
exit
REDUCED=${MAPPINGOUT}.filtered.reduced.txt
if [ ! -f ${REDUCED} ]; then
        log "Filtering BLAST results"
        # First step, select only those which size is approx. equal to MGE
        # length (i.e., more or less 10% of MGE size)
        cat $MAPPINGOUT | \
        	awk '{ if ($4 - $3 >= $5 * 0.9 && $4 - $3 <= $5 * 1.1){print $0}}' \
        	> ${MAPPINGOUT}.filtered
        # Second, apply the reduce function to remove overlapping
        # alignments
        $CONDA_PREFIX/bin/Rscript "$HOME_DIR"/ReduceOverlappingMGEs.R \
                ${MAPPINGOUT}.filtered \
        > /dev/null
        cp ${MAPPINGOUT}.filtered ${OUTPUT}/${BC}.reduced.txt
        log "Done"
else
        warn "Filtered results exist... skipping"
fi

if [ ! -f ${REDUCED}.upstream ]; then
        log "Retrieving MGE name information (this takes some time)"

        while read line; do
                grep -f <(echo $line | awk -v OFS="\t" '{ print $1, $2, $3 }') \
                ${MAPPINGOUT} | head -n1
        done < ${REDUCED} > ${REDUCED}.mge

	log "Parsing BLAST results"

	#a. hits for which we cannot extract 150bp upstreeam the MGE"
	grep -v "#" ${REDUCED}.mge | \
		awk 'BEGIN{OFS="\t"}{if($3<150){print$0}}' \
		> ${REDUCED}.upstream

        #b. hits for which we cannot extract 150bp downstream the MGE (read ends before it)"
	grep -v "#" ${REDUCED}.mge | \
		awk 'BEGIN{OFS="\t"}{if($4>$6-150){print$0}}' \
		> ${REDUCED}.downstream

	#writing hits that cannot be use (both 1 and 2 are true)"
	grep -v "#" ${REDUCED}.mge | \
		awk 'BEGIN{OFS="\t"}{if($4>$6-150 && $3<150){print$0}}' \
		> ${REDUCED}.anything


	# we have hits that can easily extract the 300bp window

	grep -v "#" ${REDUCED}.mge | \
		grep -v -f ${REDUCED}.upstream | \
		grep -v -f ${REDUCED}.downstream \
		> ${REDUCED}.extract


	# here I am writting the query files. I editted the query name so
	# that it contains: (i) the name of the read the MGE was mapped
	# (ii) the MGE size, and (iii) the MGE name. These three fields are
	# separated by '_' (see the last awk field: $2_$5_$1)

	log "Extracting 300bp flank sequences"
	$CONDA_PREFIX/bin/bedtools getfasta -fi ${FASTA} -name -bed <(cat \
		${REDUCED}.extract | \
		awk 'BEGIN{OFS="\t"}{ print $2, $3-150, $3, $2"_"$5"_"$1}') \
		> ${REDUCED}.query.upstream 2> /dev/null

	#writting downstream flank sequences"
	$CONDA_PREFIX/bin/bedtools getfasta -fi ${FASTA} -name -bed <(cat \
		${REDUCED}.extract | \
		awk 'BEGIN{OFS="\t"}{ print $2, $4, $4+150, $2"_"$5"_"$1}') \
		> ${REDUCED}.query.downstream

	$CONDA_PREFIX/bin/python "$HOME_DIR"/MergeUpstreamDownstream.py \
		-u ${REDUCED}.query.upstream \
		-d ${REDUCED}.query.downstream \
		-o ${REDUCED}.query.merged

else
	warn "Results already parsed... skipping"
fi

cp ${REDUCED}.query.merged ${OUTPUT}/${BC}-flanks-query.fa
BLASTOUT=${REDUCED}.blastn

if [ ! -f "${BLASTOUT}" ]; then
        log "Mapping flanks with BLASTn"
        $CONDA_PREFIX/bin/blastn -db ${FASTA} -query ${REDUCED}.query.merged \
		-evalue 1e-03 \
		-outfmt "7 qacc sacc sstart send length qlen slen evalue" \
		-task megablast -num_threads ${THREADS} -strand plus \
		-out $BLASTOUT > ${OUTPUT}/tmp/blastn.err 2>&1
	
else
	warn "Flanks mapping already done... skipping"
fi

cp "${BLASTOUT}" "${OUTPUT}/${BC}-flanks-results.outfmt7"
CLASSIFICATION="${OUTPUT}/${BC}_CLASSIFICATION/"

mkdir -p "${CLASSIFICATION}"

if [ ! -f "${CLASSIFICATION}/${BC}.optionalMGEs.txt" ]; then
	log "Annotating reads with unfixed MGEs"
	$CONDA_PREFIX/bin/python "$HOME_DIR"/scripts/GetNonFixedReads.py \
		--input "${BLASTOUT}" \
		--prefix "${BC}" \
		--output "${CLASSIFICATION}"

	log "Removing temporary files"
	rm -rf "${OUTPUT}"/tmp

else
	warn "Classification already done... skipping"
fi

#bash bbmap/filterbyname.sh \
#        in="${READS}" \
#        names="${CLASSIFICATION}/${BC}.optionalMGEs-readnames.txt" \
#        out="${OUTPUT}/${BC}-to-assembly.fastq" \
#        include=f qin=33
